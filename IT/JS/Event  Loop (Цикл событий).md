>[!error] Event loop не является частью движка JS (такого как V8 например). Event loop предоставляется средой (браузер или nodejs)
>Event loop в браузере и event loop в nodeJs решают одну проблему, но реализованы совсем по разному

Event Loop -- это отдельный механизм, который позволяет использовать неблокирующую модель ввода и вывода. Этот механизм осуществляет контроль стека вызовов и очереди обратных вызовов.

## Стек вызовов (Call stack)
Стек вызовов (call stack). (здесь добавить про структуру данных стек. Пока что достаточно знать, что принипы LIFO (Last input, first output)) За его обработку отвечает движок JavaScript. В стек вызовов поэтапно шаг за шагом складываются функции в том порядке, в котором они должны быть вызваны.

```js
function first() {  
    console.log('1');  
}  
  
function second() {  
    first();  
    console.log('2');  
}  
  
function third() {  
    second();  
    console.log('3');  
}  
  
third(); // 1, 2, 3
```
![[Pasted image 20230927234657.png]]
![[Pasted image 20230927234859.png]]

### Переполнение стека
Стек вызовов не бесконечный. При определенных условиях его можно переполнить и тогда приложение сломается. Стек ограничен по количеству находимых в нем функций.
![[Pasted image 20230927235152.png]]
На собеседованиях часто дают рекурсивную задачу и спросят "Что будет, если передать туда очень большое число?". Как можно избежать переполнения стека. 
В данном случае можно переписать рекурсию на цикл. (Результат будет бесконечность, но приложение не крашнется).
```js
function factorialRec(n) {  
    if (n === 1) { return 1; }  
    return n * factorialRec(n - 1);  
}  

function factorial(n) {  
    let result = 1;  
    for (let i = n; i > 1; i--) {  
        result *= i;  
    }    return result;  
}
```

## Очередь задач (Task Queue)
В Event loop так же задействована очередь.
Все асинхронные операции, в которых ожидается вызов callback помещаются в очередь задач. Мы запоминаем коллбэк и регистриуем его. ![[Pasted image 20230928000916.png]]
>[!note] Задачи из очереди выполняются ТОЛЬКО после вызовов всех функций из стека

## Как задачи попадают в очередь?
У каждого браузера есть WebAPI. Это API предоставляет timeout, обработку слушателей событий нажатия на кнопки, события загрузки изображений, отправку fetch запросов.
```js
function log(value) {  
    console.log(value);  
}  
  
setTimeout(() => {  
    log('timeout');  
});
```
1. setTimeout попадает в стек вызовов![[Pasted image 20231013195422.png]]
2. setTimeout регистрируется webApi. На этом этапе запускается таймер ![[Pasted image 20231013195448.png]]
3. После того как таймер отсчитал все что нужно, мы отправляем колбэк в очередь вызовов ![[Pasted image 20231013195508.png]]
4. После того как стек вызовов очистился (т.к. из очереди вызовов задачи берутся только в том случае, когда стек вызовов пуст), выполняется колбэк![[Pasted image 20231013195527.png]]
Т.е. порядок такой: выполнились все синхронные задачи, после истечения таймера задача переносится в очередь вызовов. И потом из очереди вызовов задача переносится в стек вызовов (после того, как стек стал пустым).